{
  "hash": "08783ef55dca35d52cab01e87557a282",
  "result": {
    "markdown": "# Calculating CWSS Scores\n\nIn this brief primer on calculating CWSS scores, I'll explain the mechanics of the calculation, then walk through an example by simulating some data and calculating CWSS scores for it. \n\n## a brief overview of notation\n\n- $A$ and $B$ are each statements which could be true or false. We don't know either way.  \n- $P(A)$ is the probability of $A$ being true, and $P(B)$ is the probability of $B$ being true.\n- $P( \\neg A)$ is the probability of $A$ being false. It is always equal to $1-P(A)$. This is also called the 'inverse probability' of $A$. \n- $P(A \\cup B)$ is the probability of either $A$ or $B$ being true.\n- $P(A \\cap B)$ is the probability of both $A$ and $B$ being true.\n\n## supporting calculations\n\nIf $A$ and $B$ are independent, which is to say that knowing whether $A$ is true or false doesn't tell us anything about whether $B$ is true or false, then the probability of both $A$ and $B$ being true $P(A \\cap B)$ is the simple product of the probabilities $P(A) \\cdot P(B)$.\nThe probability of $A$ or $B$ being true is typically given as $P(A \\cup B) = P(A) + P(B) - P(A \\cap B)$, where you add up the probabilities of $A$ and $B$, and then subtract the probability of both being true to avoid double counting it.\nHowever, since we need to perform this calculation for more than two statements, and this formula doesn't generalize especially naturally to more than two statements, we'll do a bit of double negation to get the equivalent but more general formula $P(A \\cup B) = P(\\neg (\\neg A \\cap \\neg B)) = 1 - P(\\neg A \\cap \\neg B) = 1 - (1 - P(A)) * (1 - P(B))$. This is a bit less intuitive as a formula, but it makes sense if you think about it as 'the probability of either $A$ or $B$ bieng true is the same as the probability of neither $A$ nor $B$ being false'. \nIf we had a third statement $C$, we could add it to the formula as $P(A \\cup B \\cup C) = 1 - (1 - P(A)) * (1 - P(B)) * (1 - P(C))$, and revise our natural language statement to be 'the probability that any of $A$, $B$, or $C$ is true is the same as the probability that none of $A$, $B$, or $C$ is false'.\n\n## cwss in the abstract\n\nTo apply our supporting calculations to the CWSS score, we just need to replace the placeholder statements $A$, $B$, $C$, and so on with the actual statements we're interested in, like 'learner is a woman or beyond the binary' or 'learner is Indigenous'. \nThe current inputs to the CWSS score are estimates of the percentage of the participants for which each statement is true. We can use these percentages as probabilities directly, since they're our best guess of the probability of each statement being true. \nFor example (and for our purposes), \"10% of learners are Indigenous\" is the same as \"the probability that a learner is Indigenous is 0.1\" or $P(Indigenous) = 0.1$.\nEquivalently, \"80% of learners are women or beyond the binary\" is the same as $P(Woman\\ or\\ beyond) = 0.8$.\nIf we were only striving to serve those two communities, we would calculate the CWSS score as $CWSS = P(Indigenous \\cup Woman\\ or\\ beyond) = 1 - (1 - P(Indigenous)) * (1 - P(Woman\\ or\\ beyond)) = 1 - (1 - 0.1) * (1 - 0.8) = 0.82$.\nIn reality, the CWSS score generated by this process is just an estimate of the true proportion of learners who belong to one or more of the target communities. Even if our assumption of independence holds, there will remain some error. \n\n## an example\n\n:::{.callout-note}\nThroughout this example, I'm going to work in R because that's what I'm familiar with. If you're not comfortable with it, that's all good, the important point is the math, not the code. \n:::\n\nThe R packages in the 'tidyverse' have grown to become the standard toolkit for data analysis in R. \nThe `dplyr` package provides a critical set of data manipulation functions that make it easy to work with data in a way that's easy to read and understand.\n\n\n::: {.cell caption='load the packages we\\'ll need'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(ggdist)\n```\n:::\n\n\nSome fake data about fake people. You won't need to do this step, since you already have real data. This is just to illustrate the process and its accuracy.\n\n\n::: {.cell caption='create some fake data'}\n\n```{.r .cell-code}\n# sim_learners produces a tibble (a data frame) with n rows, each representing a learner.\n# Each column is a community we strive to serve\n# Each cell is TRUE if the learner belongs to that community, or FALSE if not\n# It also includes a column cwss_actual, which is true if the learner belongs to any of the communities\nsim_learners <- function(n) {\n    res <-\n        tibble::tibble(\n            women_and_beyond = sample(c(TRUE, FALSE), n, replace = TRUE, prob = c(0.5, 0.5)),\n            low_income = sample(c(TRUE, FALSE), n, replace = TRUE, prob = c(0.3, 0.7)),\n            newcomer = sample(c(TRUE, FALSE), n, replace = TRUE, prob = c(0.1, 0.9)),\n            physical_disability = sample(c(TRUE, FALSE), n, replace = TRUE, prob = c(0.05, 0.95))\n        ) |>\n        mutate(\n            cwss_actual = women_and_beyond | low_income | newcomer | physical_disability\n        )\n\n    res\n}\n# always set the random seed when you doing simulations\nset.seed(1234)\n\nlearners <- sim_learners(5000)\n\nreadr::write_rds(learners, \"data/learners.rds\")\n\nknitr::kable(head(learners))\n```\n\n::: {.cell-output-display}\n|women_and_beyond |low_income |newcomer |physical_disability |cwss_actual |\n|:----------------|:----------|:--------|:-------------------|:-----------|\n|FALSE            |FALSE      |FALSE    |FALSE               |FALSE       |\n|TRUE             |FALSE      |FALSE    |FALSE               |TRUE        |\n|TRUE             |TRUE       |FALSE    |FALSE               |TRUE        |\n|TRUE             |FALSE      |TRUE     |FALSE               |TRUE        |\n|TRUE             |FALSE      |FALSE    |FALSE               |TRUE        |\n|TRUE             |TRUE       |FALSE    |FALSE               |TRUE        |\n:::\n:::\n\n\n\nNow that we have the data, we can calculate the membership probabilities for each community, then calculate the CWSS score and compare it to the CWSS actual value. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_cwss <- function(d) {\n    d |>\n        summarize(across(everything(), mean)) |>\n        mutate(\n            cwss_score = 1 - (\n                (1 - women_and_beyond) *\n                    (1 - low_income) *\n                    (1 - newcomer) *\n                    (1 - physical_disability)\n            ),\n            cwss_error = cwss_score - cwss_actual\n        )\n}\n\ncwss_summary <- calculate_cwss(learners)\n\nreadr::write_rds(cwss_summary, \"data/cwss_summary.rds\")\n\nknitr::kable(cwss_summary)\n```\n\n::: {.cell-output-display}\n| women_and_beyond| low_income| newcomer| physical_disability| cwss_actual| cwss_score| cwss_error|\n|----------------:|----------:|--------:|-------------------:|-----------:|----------:|----------:|\n|           0.5014|     0.2968|   0.1002|              0.0468|      0.7018|  0.6992808| -0.0025192|\n:::\n:::\n\n\nWe can see that, with 5000 learners, the CWSS score is, in this case, accurate to a single percentage point. \nWhile this level of accuracy depends on the structural truth of the independence assumption (which we enforced in our simulation), \nit should indicate that this approach yields a more accurate and interpretable result than the current method. \n",
    "supporting": [
      "02-01_cwss-score_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}