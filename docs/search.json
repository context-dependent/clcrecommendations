[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practical Technicalities",
    "section": "",
    "text": "Warning\n\n\n\nThis chapter is currently under active development. Use its content as it is helpful, but please moderate your expectations. If you’re interested in helping out with its development, head over to the repo\n\n\nThis ‘book’ comprises a set of recommendations for the Canada Learning Code (CLC) evaluation team, aimed at helping them improve their data analysis and reporting process. The recommendations are based on the results of a review of the CLC evaluation team’s current process. The review of the CLC evaluation team’s current process was conducted by the author, in collaboration with the CLC evaluation team. The primary concerns of the recommendations are analysis methods and data management processes. A secondary concern is more forward looking, dealing with potential additions or modifications to CLC’s data collection strategy.\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books."
  },
  {
    "objectID": "02-01_cwss-score.html",
    "href": "02-01_cwss-score.html",
    "title": "1  Calculating CWSS Scores",
    "section": "",
    "text": "In this brief primer on calculating CWSS scores, I’ll explain the mechanics of the calculation, then walk through an example by simulating some data and calculating CWSS scores for it."
  },
  {
    "objectID": "02-01_cwss-score.html#a-brief-overview-of-notation",
    "href": "02-01_cwss-score.html#a-brief-overview-of-notation",
    "title": "1  Calculating CWSS Scores",
    "section": "1.1 a brief overview of notation",
    "text": "1.1 a brief overview of notation\n\n\\(A\\) and \\(B\\) are each statements which could be true or false. We don’t know either way.\n\n\\(P(A)\\) is the probability of \\(A\\) being true, and \\(P(B)\\) is the probability of \\(B\\) being true.\n\\(P( \\neg A)\\) is the probability of \\(A\\) being false. It is always equal to \\(1-P(A)\\). This is also called the ‘inverse probability’ of \\(A\\).\n\\(P(A \\cup B)\\) is the probability of either \\(A\\) or \\(B\\) being true.\n\\(P(A \\cap B)\\) is the probability of both \\(A\\) and \\(B\\) being true."
  },
  {
    "objectID": "02-01_cwss-score.html#supporting-calculations",
    "href": "02-01_cwss-score.html#supporting-calculations",
    "title": "1  Calculating CWSS Scores",
    "section": "1.2 supporting calculations",
    "text": "1.2 supporting calculations\n\nIf \\(A\\) and \\(B\\) are independent, which is to say that knowing whether \\(A\\) is true or false doesn’t tell us anything about whether \\(B\\) is true or false, then the probability of both \\(A\\) and \\(B\\) being true \\(P(A \\cap B)\\) is the simple product of the probabilities \\(P(A) \\cdot P(B)\\).\nThe probability of \\(A\\) or \\(B\\) being true is typically given as \\(P(A \\cup B) = P(A) + P(B) - P(A \\cap B)\\), where you add up the probabilities of \\(A\\) and \\(B\\), and then subtract the probability of both being true to avoid double counting it.\nHowever, since we need to perform this calculation for more than two statements, and this formula doesn’t generalize especially naturally to more than two statements, we’ll do a bit of double negation to get the equivalent but more general formula \\(P(A \\cup B) = P(\\neg (\\neg A \\cap \\neg B)) = 1 - P(\\neg A \\cap \\neg B) = 1 - (1 - P(A)) * (1 - P(B))\\). This is a bit less intuitive as a formula, but it makes sense if you think about it as ‘the probability of either \\(A\\) or \\(B\\) bieng true is the same as the probability of neither \\(A\\) nor \\(B\\) being false’.\nIf we had a third statement \\(C\\), we could add it to the formula as \\(P(A \\cup B \\cup C) = 1 - (1 - P(A)) * (1 - P(B)) * (1 - P(C))\\), and revise our natural language statement to be ‘the probability that any of \\(A\\), \\(B\\), or \\(C\\) is true is the same as the probability that none of \\(A\\), \\(B\\), or \\(C\\) is false’."
  },
  {
    "objectID": "02-01_cwss-score.html#calculating-cwss",
    "href": "02-01_cwss-score.html#calculating-cwss",
    "title": "1  Calculating CWSS Scores",
    "section": "1.3 Calculating CWSS",
    "text": "1.3 Calculating CWSS\n\nTo apply our supporting calculations to the CWSS score, we just need to replace the placeholder statements \\(A\\), \\(B\\), \\(C\\), and so on with the actual statements we’re interested in, like ‘learner is a woman or beyond the binary’ or ‘learner is Indigenous’.\nThe current inputs to the CWSS score are estimates of the percentage of the participants for which each statement is true. We can use these percentages as probabilities directly, since they’re our best guess of the probability of each statement being true.\nFor example (and for our purposes), “10% of learners are Indigenous” is the same as “the probability that a learner is Indigenous is 0.1” or \\(P(Indigenous) = 0.1\\).\nEquivalently, “80% of learners are women or beyond the binary” is the same as \\(P(Woman\\ or\\ beyond) = 0.8\\).\nIf we were only striving to serve those two communities, we would calculate the CWSS score as \\(CWSS = P(Indigenous \\cup Woman\\ or\\ beyond) = 1 - (1 - P(Indigenous)) * (1 - P(Woman\\ or\\ beyond)) = 1 - (1 - 0.1) * (1 - 0.8) = 0.82\\).\nIn reality, the CWSS score generated by this process is just an estimate of the true proportion of learners who belong to one or more of the target communities. Even if our assumption of independence holds, there will remain some error."
  },
  {
    "objectID": "02-01_cwss-score.html#an-example",
    "href": "02-01_cwss-score.html#an-example",
    "title": "1  Calculating CWSS Scores",
    "section": "1.4 an example",
    "text": "1.4 an example\n\n\n\n\n\n\nNote\n\n\n\nThroughout this example, I’m going to work in R because that’s what I’m familiar with. If you’re not comfortable with it, that’s all good, the important point is the math, not the code.\n\n\nThe R packages in the ‘tidyverse’ have grown to become the standard toolkit for data analysis in R. The dplyr package provides a critical set of data manipulation functions that make it easy to work with data in a way that’s easy to read and understand.\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(purrr)\nlibrary(ggdist)\n\nSome fake data about fake people. You won’t need to do this step, since you already have real data. This is just to illustrate the process and its accuracy.\n\n# sim_learners produces a tibble (a data frame) with n rows, each representing a learner.\n# Each column is a community we strive to serve\n# Each cell is TRUE if the learner belongs to that community, or FALSE if not\n# It also includes a column cwss_actual, which is true if the learner belongs to any of the communities\nsim_learners <- function(n) {\n    res <-\n        tibble::tibble(\n            women_and_beyond = sample(c(TRUE, FALSE), n, replace = TRUE, prob = c(0.5, 0.5)),\n            low_income = sample(c(TRUE, FALSE), n, replace = TRUE, prob = c(0.3, 0.7)),\n            newcomer = sample(c(TRUE, FALSE), n, replace = TRUE, prob = c(0.1, 0.9)),\n            physical_disability = sample(c(TRUE, FALSE), n, replace = TRUE, prob = c(0.05, 0.95))\n        ) |>\n        mutate(\n            cwss_actual = women_and_beyond | low_income | newcomer | physical_disability\n        )\n\n    res\n}\n\n# always set the random seed when you're doing simulations\nset.seed(1234)\n\nlearners <- sim_learners(5000)\n\nknitr::kable(head(learners))\n\n\n\n\n\n\n\n\n\n\n\nwomen_and_beyond\nlow_income\nnewcomer\nphysical_disability\ncwss_actual\n\n\n\n\nFALSE\nFALSE\nFALSE\nFALSE\nFALSE\n\n\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nTRUE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nFALSE\nTRUE\nFALSE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nTRUE\nFALSE\nFALSE\nTRUE\n\n\n\n\n\nNow that we have the data, we can calculate the membership probabilities for each community, then calculate the CWSS score and compare it to the CWSS actual value.\n\ncalculate_cwss <- function(d) {\n    d |>\n        summarize(across(everything(), mean)) |>\n        mutate(\n            cwss_score = 1 - (\n                (1 - women_and_beyond) *\n                    (1 - low_income) *\n                    (1 - newcomer) *\n                    (1 - physical_disability)\n            ),\n            cwss_error = cwss_score - cwss_actual\n        )\n}\n\ncwss_summary <- calculate_cwss(learners)\n\nknitr::kable(cwss_summary)\n\n\n\n\n\n\n\n\n\n\n\n\n\nwomen_and_beyond\nlow_income\nnewcomer\nphysical_disability\ncwss_actual\ncwss_score\ncwss_error\n\n\n\n\n0.5014\n0.2968\n0.1002\n0.0468\n0.7018\n0.6992808\n-0.0025192\n\n\n\n\n\nWe can see that, with 5000 learners, the CWSS score is, in this case, accurate to a single percentage point. While this level of accuracy depends on the structural truth of the independence assumption (which we enforced in our simulation), it should indicate that this approach yields a more interpretable result than the current method."
  }
]